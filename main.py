from models import Graph, Edge, Solution
from utilities import custom_logger, parser, writer
from algorithms import kruskal_path, dijkstra_path, find_path
from multiprocessing import Process
import logging
import visualization
import copy


def main_algorithm():
    problems = parser.parse()

    logger = logging.getLogger('main_logger')

    pb = problems[2]

    graph = Graph(pb)
    graph.sort_edges()
    solution_edges = set()

    logger.info('Generating Dijkstra Routes')
    pb_robots = copy.deepcopy(pb.robots)

    # Special for the first robot
    r_f = pb_robots.pop(0)
    r_f.awaken = True

    pb_robots = sorted(pb_robots, key=lambda robot: Edge(r_f.vertices, robot.vertices, None).weight)
    v = list()

    v.append(pb_robots[0].vertices)
    solution_edges = solution_edges.union(set(dijkstra_path(v_1=r_f.vertices,
                                                            v_2=pb_robots[0].vertices,
                                                            vertices=graph.vertices,
                                                            edges=graph.edges)))
    pb_robots[0].awaken = True
    while len(pb_robots) > 0:
        logger.info('Generating Dijkstra, remaining: %i' % len(pb_robots))
        r_i = pb_robots.pop(0)
        v_i = r_i.vertices

        prev, dist = find_path(v_1=v_i,
                               vertices=graph.vertices,
                               edges=graph.edges)

        pb_robots = sorted(pb_robots, key=lambda robot: dist[robot.vertices])

        robots = list()
        # Select Destination robots that have not been reached. They should not be a destination.
        for i in range(0, len(pb_robots)):
            if pb_robots[i].awaken:
                continue
            robots.append(pb_robots[i])

            if i < len(pb_robots)-1:
                robots.append(pb_robots[i+1])

            if len(robots) is 2:
                break

        for r in robots:
            r.awaken = True
            edges = set(dijkstra_path(v_i, r.vertices, graph.vertices, graph.edges))  # Generated by Dijkstra

            found = False
            for edge in edges:

                for sol_edge in solution_edges:

                    if edge.start == sol_edge.start and edge.end == sol_edge.end:
                        found = True
                        break

                    if edge.start == sol_edge.end and edge.end == sol_edge.start:
                        found = True
                        break

            if found:
                r.awaken = False
                continue

            solution_edges = solution_edges.union(edges)


    logger.info('Generating Dijkstra Routes Complete')
    logger.info('Visualizing the solution')
    # Visualize is using process (non blocking)
    Process(target=visualization.draw(pb, mst_edges=list(solution_edges), edges=graph.edges)).start()

if __name__ == "__main__":
    custom_logger.start_logger()
    main_algorithm()
